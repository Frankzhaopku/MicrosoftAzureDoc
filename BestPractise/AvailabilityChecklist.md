#可用性清单
===

##应用设计
---

* **避免所有的[单点故障](https://en.wikipedia.org/wiki/Single_point_of_failure)**：所有的组件、服务、资源和计算实例都应该以多例方式部署，以避免因单点故障导致而导致可用性受到影响。这也包括了用户登录机制。将应用设计为可配置多例部署、自动检测实例故障并将请求重定向到非故障实例上，一般平台都不会自动实现这个机制。

* **为每一个[SLA](https://en.wikipedia.org/wiki/End-user_license_agreement)分解工作**：若一个服务有关键工作和非关键工作组成，应该分别管理这些工作，并根据服务的特点来配置不同数量的实例使得其可以达到可用性指标要求。

* **最小化并了解服务依赖**：尽可能减少使用的服务，并确保你完全了解系统中使用的服务的特性与依赖关系。包括这些依赖的特点以及每一个依赖的故障或性能损失对整个应用的影响。Microsoft对于大多数服务都保证了至少99.9%的可用性，但是这表示你的应用每多使用一个依赖服务会导致系统在可用性上有0.1%故障的可能性积累。

* **将任务和消息设计为[幂等](https://en.wikipedia.org/wiki/Idempotence)的**：这样的话重复请求并不会导致问题。例如，一个服务作为消费者角色处理由其他作为生产者角色发出的请求消息。当消费者服务在处理消息但没来得及确认返回时发生了故障，那么生产者很可能会再次发送请求，该请求将可能被另一个消费者服务接到。因此消费者服务应该对于重复操作有幂等性，这样不会因为重复执行之前的操作而导致非法结果。这意味着使用重复消息检测或使用乐观控制保证一致性的方法来解决冲突。

* **为关键事务使用具有高可用性的消息代理**：很多场景下，我们都是用消息传递指令以发起任务或进行远程调用。为了较好的性能表现，应用应该发送消息后立即返回，而不用等待收到回复。消息系统应该具有极高的可用性以保证消息可以被送达。服务总线消息队列（Service Bus Message Queues）应该实现*至少一次*语义，虽然有时候可能会接收到重复的消息，但是一个进入消息队列的消息不应该丢失。如果消息处理是幂等的（见上条），则消息的重复送达并不会导致错误。

* **将应用设计为可以优雅降级的**：当资源使用到达极限时，应该在尽量减少对用户影响的情况下采用适当的措施。有些情况下，应用的负载会超过一个或多个部分的承受能力，导致可用性的降低和连接失败。水平扩展可以缓解这个问题，但依然可能因资源或成本因素而到达极限。应该将应用设计为在这种情况下可以自动优雅降级。例如，一个电商系统中，订单处理系统处于过压状态（甚至已经完全故障失效），应该可以在允许其他部分（如查看商品目录等）正常运作的情况下暂时停止这个子系统。延迟发往一个失效子系统的请求时比较合适的做法，例如在订单子系统恢复前依然允许用户提交订单，但只是将订单存入一个队列或其他的安全存储机制中。

* **优雅处理迅速爆发性事件**：大多数应用都需要根据时间的不同来处理不同的工作负载，如商务系统中早上会遇到一个高峰或电商网站发布新的产品时等。自动伸缩（auto-scaling）有助于处理此类问题，但新的实例上线并处理请求时需要一定时间的。为了防止突发的意外爆发性活动导致应用故障，应该将其设计为将服务请求放入消息队列中，并在队列容量将满时进行优雅降级处理。仅需确保在正常情况下有足够的性能和容量处理消息队列中的所有未处理消息即可。有关的详细信息，请参见[基于队列的负载调配操作模式]()

##部署与维护
---

* **为每个服务部署多个实例**：Microsoft对用户创建部署的服务可用性做出一定的保证，但这些保证只有在为每个服务部署了至少两个实例的时候才是有效的。这样可以使一个实例出现故障时让另一个实例提供服务。在对线上系统进行升级而不想对客户有任何影响时，这样的部署方式是极为重要的，这样的话可以在某一实例提供服务时单独关闭并升级另一实例。

* **服务器应用应该在多个不同的数据中心**：即便可能性极小，但整个数据中心依然有可能因为自然灾害或大规模Internet故障而全体停机。核心的重要业务应该被部署在多个不同的数据中心中以保证可用性的最大化。这样做另外的好处是减少本地用户的网络延迟，并为升级应用提供了更多的灵活性。

* **测试并自动化部署与维护任务**：分布式应用需要由多个必须同时运作的组件组成，因此应该使用经过测试的部署机制，例如脚本或用于升级验证配置的部署应用来自动化部署的过程。自动化技术也应该用在一些应用内的组件升级过程上。当然，全面测试部署过程以保证过程中的错误不会导致服务失效是至关重要的。所有的部署工具都应该有相应的安全限制来保护已经部署的应用，应该仔细定义并执行部署策略，以减少人工干预的必要性。

* **考虑使用平台提供的开发与生产环境相关特性**：例如，在使用Azure云服务时，应用的开发环境和生产环境的可以通过切换虚拟IP地址（[VIP swap]()）进行切换。但如果你希望开发与生产环境同时上线并逐渐做用户迁移，那么可能并不适合这个服务。

* 尽可能**在不重启服务的情况下应用新的配置**：在很多情况下，Azure应用或服务都可以在不重启实例的情况下修改配置。实例会注册监听配置更改的事件，并在配置发生改变时将这些改变自动应用到组件中去，但确实有一些涉及核心平台的配置会要求服务必须重启。在构建组件和服务时，应该通过使组件无需要求整个系统来重启即可改变配置来做到可用性最大化与停机时间最小化。

* **使用升级域（Upgrade domain）做到零停机升级**：Azure的计算单元，如web和worker都安置在升级域中。升级域会将所有的实例集中起来，当升级开始时，每一个实例会依次停机、升级、重启，这样便最小化了应用升级对用户造成的影响。在服务部署时你可以指定为服务创建多少个升级域。
	> **注意**：实例同样会分布在不同的故障域（Fault domain）中，这些域的服务器、电力、冷却系统都是完全独立的，这样可以最小化因为基础设施故障导致的实例停机。这样的分布是自动且用户不可控的。

* **为Azure的虚拟机配置可用集（Availability sets）**：将两个或以上的虚拟机放入同一个可用集中可以保证这些虚拟机不会被部署到同一个故障域中。为了最大化可用性，应该为每一个关键虚拟机启动多个实例，并将其放入同一可用集中。如果你在使用多个虚拟机进行不同的服务，为每一个虚拟机建立一个可用集并将不同虚拟机的实例放入相应的可用集中。例如，当你使用不同的虚拟机作为Web服务器和报表服务器时，你应当分别为它们建立不同的可用集并将Web服务器虚拟机放入Web服务器可用集，将报表服务器虚拟机实例放入报表服务器可用集。

##数据管理
---

* **利用[数据复制](https://en.wikipedia.org/wiki/Replication_(computing))**（本地和远程冗余）：为了防止因基础设施故障导致的数据丢失，Azure存储的数据会自动进行冗余复制，而且其中部分参数是可配置的。例如，只读数据会被复制到一个以上不在同一地理区域的数据中心（[RA-GRS]()）。不过使用RA-GRS会有额外的收费，详情关注[Azure存储价格]()。

* 尽可能**使用[乐观并发](https://en.wikipedia.org/wiki/Optimistic_concurrency_control)与[最终一致性](https://en.wikipedia.org/wiki/Eventual_consistency)**：通过锁来阻塞资源访问的并发控制方式会导致很差的性能并进一步影响到可用性，这个问题在分布式系统中尤为严重。很多情况下，利用良好的设计和技术手段，例如[分片](https://en.wikipedia.org/wiki/Partition_(database))，可以有效降低更新冲突的可能性。当数据处于复制冗余情况下时，数据会逐渐达到最终一致，但这样的带来的好处一般还是要远远大于立即一致的事物性处理。

* **使用定期备份和时间点恢复**：并保证其满足[恢复点目标](https://en.wikipedia.org/wiki/Recovery_point_objective)。定期自动备份数据，并应保证故障发生时可以可靠的恢复数据与应用。需要注意的是，复制集并不是一种备份机制，因为由错误、故障或误操作导致的数据错误最终会被所有的复制集所同步。为了保证数据传输和存储的安全，备份过程应该是保密的。通常数据库或部分数据存储可以通过事务日志恢复到之前的某个时间点。Azure为Azure SQL Database提供了数据库备份机制，数据会被导出到Azure云存储的一个备份包里，并可以被下载安放在一个安全的存储环境中。

* **启用高可用性选项来启动Redis缓存的冗余备份**：当使用Redis Cache时，选择标准设置来维护一个内容的冗余备份，更多详情查阅[在Azure Redis Cache中建立缓存]()。

##错误与故障
---

* **[超时](https://en.wikipedia.org/wiki/Timeout_(computing))的概念**：服务或资源可能因不可用而导致客户端请求失败。应该为每个服务和资源以及相应的客户端请求设置适当的超时时间（有些情况下，需要根据客户端的上下文和具体操作为特定实例单独设置超时时间）。在访问有一定延时的服务或资源时，若设定了过短的超时时间，会导致大量的重试请求。但过长的超时设置也可能会因访问服务或资源的队列中挂起的请求过多而导致阻塞。

* **对瞬时故障导致的操作失败进行重试**：对于所有不原生支持自动重试的服务和资源设计重试策略。可以使用随着重试次数的增加而增加重试时间间隔的策略，以防止服务访问过载，这样也可以使服务有余地可以恢复并处理队列中的请求。短时间内的小间隔连续重试很可能会导致问题进一步恶化。

* 当服务**失效**时**停止请求以防止[连锁故障](https://en.wikipedia.org/wiki/Cascading_failure)**：有时候因部分连接失效到服务彻底失效不同程度的故障会耗费超乎预期的时间才能恢复。另外，当一个服务非常繁忙时，系统中某个部分的故障可能会导致连锁故障，结果是导致临界系统资源如内存、线程和数据库的访问操作全部阻塞。此时与其反复重试操作，不如接受服务失效的事实并处理该故障。也可以使用[断路器模式](https://en.wikipedia.org/wiki/Circuit_breaker_design_pattern)在规定期间内拒绝特定请求。详情可以参考MSDN上关于断路器模式的[文章](https://msdn.microsoft.com/library/dn589784.aspx)。

* **组合或回退到多个组件**以缓和特定服务离线或失效的影响：尽可能在不影响现有服务的情况下使用多实例部署，在多实例间均衡请求负载，并自动检测实例失效，避免向失效实例发送请求，可以大幅度提高可用性。

* 可能的话**退到另一个服务或工作流上**：例如，如果写入数据库失败，可以暂时将数据存储在云存储空间里，并提供数据库服务恢复后从云存储空间重写的机制。一些情况下，操作需要在服务失效时有一个替代性方案使得工作流可以继续进行下去。可能的话，自动检测服务失效并将请求重定向到合适的替代功能上。

##监控与[灾难恢复](https://en.wikipedia.org/wiki/Disaster_recovery)
---

* 为运维人员**提供可以报告故障或可能故障事件的丰富仪表监控**：对于可能但还没有发生的故障，应该为运维人员提供充足的数据来诊断原因、缓解问题并保证系统继续可用。对于已经发生的故障，应该给用户返回合适的信息并尽量继续运行，即使功能可能受到影响。在任何时候，监控系统都应该收集尽可能丰富的数据细节使得运维人员可以尽快实施恢复工作，如果需要的话，使设计与开发人员可以快速修改系统以防止再次出现类似的情况。

* **通过检测功能来监控系统的健康情况**：应用的健康状况和性能可以会随着时间发生难以察觉的递减并直到出现故障。预防此类情况的一种方法是实现一个定期从应用外部运行的检测功能。这些检测可以非常简单，例如测量整体应用、单个应用部件、单个服务或单个组件的响应时间。检测功能主要是从系统中抽取数据，检查其是否可以产生正确结果，监控服务延迟及检查可用性。

* **定期测试所有恢复系统与备援系统**：应保证这些系统是可用且正常工作的。对主系统的改动可能会影响到恢复系统和备援系统，但是这种影响一般在主系统故障或过载前不易被发现。在运行时状态下出现问题并需要恢复之前定期对其进行测试是一个不错的实践。

* **测试监控系统**：恢复系统与备援系统的自动化、监控系统健康与性能的可视化仪表盘都依赖于监控系统的正确性。如果这些部件失效，例如错过重要的信息、上报不准确的数据等都可能导致运维人员无法系统的健康或故障问题。

* **对较长的工作流进行过程追踪**：较长的工作流通常由多个步骤组成。设计此类工作流时应该保证不同的步骤之间是相对独立并且在出问题时可以单独重试而无需整个流程进行回滚。使用例如调度程序代理管理者模式来监控较长的工作流，详情关注MSDN上的文章[调度程序代理管理者模式](https://msdn.microsoft.com/library/dn589780.aspx)。

* **计划好灾难恢复**：确保有文档，以及全面测试过的系统恢复计划。定期测试检查恢复流程并保证运维人员对流程足够熟悉。
