#可用性清单
===

## 应用设计
---
* **避免所有的[单点故障](https://en.wikipedia.org/wiki/Single_point_of_failure)** 所有的组件、服务、资源和计算实例都应该以多例方式部署，以避免因单点故障导致而导致可用性受到影响。这也包括了用户登录机制。将应用设计为可配置多例部署、自动检测实例故障并将请求重定向到非故障实例上，一般平台都不会自动实现这个机制。
* **为每一个[SLA](https://en.wikipedia.org/wiki/End-user_license_agreement)分解工作** 若一个服务有关键工作和非关键工作组成，应该分别管理这些工作，并根据服务的特点来配置不同数量的实例使得其可以达到可用性指标要求。
* **最小化并了解服务依赖** 尽可能减少使用的服务，并确保你完全了解系统中使用的服务的特性与依赖关系。包括这些依赖的特点以及每一个依赖的故障或性能损失对整个应用的影响。Microsoft对于大多数服务都保证了至少99.9%的可用性，但是这表示你的应用每多使用一个依赖服务会导致系统在可用性上有0.1%故障的可能性积累。
* **将任务和消息设计为[幂等](https://en.wikipedia.org/wiki/Idempotence)的** 这样的话重复请求并不会导致问题。例如，一个服务作为消费者角色处理由其他作为生产者角色发出的请求消息。当消费者服务在处理消息但没来得及确认返回时发生了故障，那么生产者很可能会再次发送请求，该请求将可能被另一个消费者服务接到。因此消费者服务应该对于重复操作有幂等性，这样不会因为重复执行之前的操作而导致非法结果。这意味着使用重复消息检测或使用乐观控制保证一致性的方法来解决冲突。
* **为关键事务使用具有高可用性的消息代理** 很多场景下，我们都是用消息传递指令以发起任务或进行远程调用。为了较好的性能表现，应用应该发送消息后立即返回，而不用等待收到回复。消息系统应该具有极高的可用性以保证消息可以被送达。服务总线消息队列（Service Bus Message Queues）应该实现*至少一次*语义，虽然有时候可能会接收到重复的消息，但是一个进入消息队列的消息不应该丢失。如果消息处理是幂等的（见上条），则消息的重复送达并不会导致错误。
* **将应用设计为可以优雅降级的** 当资源使用到达极限时，应该在尽量减少对用户影响的情况下采用适当的措施。有些情况下，应用的负载会超过一个或多个部分的承受能力，导致可用性的降低和连接失败。水平扩展可以缓解这个问题，但依然可能因资源或成本因素而到达极限。应该将应用设计为在这种情况下可以自动优雅降级。例如，一个电商系统中，订单处理系统处于过压状态（甚至已经完全故障失效），应该可以在允许其他部分（如查看商品目录等）正常运作的情况下暂时停止这个子系统。延迟发往一个失效子系统的请求时比较合适的做法，例如在订单子系统恢复前依然允许用户提交订单，但只是将订单存入一个队列或其他的安全存储机制中。
* **优雅处理迅速爆发性事件** 大多数应用都需要根据时间的不同来处理不同的工作负载，如商务系统中早上会遇到一个高峰或电商网站发布新的产品时等。自动伸缩（auto-scaling）有助于处理此类问题，但新的实例上线并处理请求时需要一定时间的。为了防止突发的意外爆发性活动导致应用故障，应该将其设计为将服务请求放入消息队列中，并在队列容量将满时进行优雅降级处理。仅需确保在正常情况下有足够的性能和容量处理消息队列中的所有未处理消息即可。有关的详细信息，请参见[基于队列的负载调配操作模式]()
